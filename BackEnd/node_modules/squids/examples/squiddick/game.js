
/*
Copyright 2022  Sleepless Software Inc.  All Rights Reserved

See the LICENSE.txt file included with the Squids source code for 
licensing information


TODO:
	demonstrate:
		- using pointer_x,pointer_y
		- seq()
		- draw_text()
		- draw_line()
		- custom event dispatch
		- gravity
		- clone()
		- particles

*/

// Any fonts that the browser has available to it can be created
let font = load_font( "Arial", 30, "turquoise" );

// Squids creates a global canvas reference
let sw = canvas.width;
let sh = canvas.height;

// This is where I'm going to store the images and sounds that I've loaded
let assets = {};


// convenience function for dislaying numbers more clearly in debug msgs
// clips to 2 decimals - changes 1.6666666666666 to "1.67"
function rndhun( n ) {
	return round( n * 100 ) / 100
}

// ---------------------------------------------
// Set up and show the loading screen
// ---------------------------------------------
function load() {

	reset();	// clears all squids and turns off all audio

	// Create a squid to manage the loading screen
	let loader = new Squid();

	let progress_msg = "";

	// listen for the draw event and do our own custom rendering.
	loader.listen( "draw", () => {

		draw_text( "The Chronicles of Squiddick", sw * 0.5, sh * 0.3, font, "center", 1 );
		draw_text( progress_msg, sw * 0.5, sh * 0.4, font, "center", 0.5 );

	} );

	// Start actually loading the assets
	load_assets( [ 
		"blot.png",
		"bubble.png",
		"fish0-lt.png",
		"fish0-rt.png",
		"fish1-lt.png",
		"fish1-rt.png",
		"frank.png",
		"squid_0.png",
		"squid_1.png",
		"squid_2.png",
		"squid_3.png",
		"squid_4.png",
		"sub1.png",
		"sub2.png",
		"tiles.png",
	], [
		"underwater.mp3",
		"slurp.mp3",
		"chomp.mp3",
		"sploo.mp3",
		"music.mp3",
	], ( progress, file, asset, type ) => {

		// This is called each time a file is loaded

		assets[ file ] = asset;		// store asset for use in game

		progress_msg = "Loading: "+round( progress * 100 ) + "% " +  file;

		if( progress >= 1.0 ) {
			// the loading is complete
			start();	// advance to start screen
		}

	}, console.error );

}


// ---------------------------------------------
// Set up and show the start screen
// ---------------------------------------------
function start() {

	reset();	// clears all squids and turns off all audio

	// Create a squid to manage the start screen
	starter = new Squid();

	// listen for the draw event and do our own custom rendering.
	starter.listen( "draw", () => {
		draw_text( "The Chronicles of Squiddick", sw * 0.5, sh * 0.3, font, "center", 0.5 );
		draw_text( "Click to Start ", sw * 0.5, sh * 0.4, font, "center", 1 );
		draw_text( "WASD = drive submarine. ", sw * 0.5, sh * 0.55, font, "center", 0.5 );
		draw_text( "Click the squid for ink!", sw * 0.5, sh * 0.60, font, "center", 0.5 );
		draw_text( "M = turn off music", sw * 0.5, sh * 0.65, font, "center", 0.5 );
		draw_text( "CTRL+` = toggle debug mode", sw * 0.5, sh * 0.70, font, "center", 0.5 );
		draw_text( "R = reset game", sw * 0.5, sh * 0.75, font, "center", 0.5 );
	} );

	// listen for a pointerdown event
	starter.listen( "pointerdown", () => {
		game();				// advance to the game proper
	} )

}


// ---------------------------------------------
// Set up and show the main game screen.
// ---------------------------------------------
function game() {

	reset();	// clears all squids and turns off all audio

	// set up my background music
	music = assets["music.mp3"];	// get the sound object
	music.volume( 0.2 );			// reduce the volume
	music.play();					// start it playing
	// detect when bg music is done so i can loop it.
	music.on( "end", () => {
		music.play();
	} );


	// set up my looping, watery background sounds
	water = assets["underwater.mp3"];
	water.volume( 0.3 );
	water.play();
	water.on( "end", () => {
		water.play();
	} );


	// just a handy way for me to prevent the bg sounds for development
	let qd = getQueryData();
	if( !! qd.nomusic ) {
		music.volume( 0 );
		water.volume( 0 );
	}

	debug = !! qd.debug;


	// grab some sound effects and prep them
	slurp = assets["slurp.mp3"];
	slurp.volume( 0.5 );

	sploo = assets["sploo.mp3"];
	sploo.volume( 1.0 );

	chomp = assets["chomp.mp3"];
	chomp.volume( 0.4 );


	//	-	-	-	-	-	-	-	-	-	-	-	-
	// Bubble stuff

	// this creates a single bubble
	const mk_bubble = function() {

		let bubble = new Squid( vec( sw * rand(), sh ), assets[ "bubble.png" ] );
		bubble.name = "bubble-"+bubble.id;

		let n = rand();

		bubble.scale = 0.05 + ( n * 0.5 );
		bubble.opacity = bubble.scale * 5.0;

		bubble.velocity = vec( 0,  -n );

		bubble.draw_priority( toInt( n * 4 ) );

		bubble.listen( "tick", ( delta, tick_num ) => {
			if( bubble.position.y < -10 ) {
				// went off top of screen
				bubble.position = vec( rand() * sw, sh + 20 );	// wrap around to bottom
			}
		} );

		return bubble;
	};

	// create a bunch of bubbles for the open ocean
	const NUM_BUBBLES = 25;
	let bubbles = [];
	for( let i = 0 ; i < NUM_BUBBLES ; i++ ) {
		bubbles.push( mk_bubble() );
	}

	// create some other bubbles that will come out of the submarine
	const NUM_SUB_BUBBLES = 15;
	let sub_bubbles = [];
	for( let i = 0 ; i < NUM_SUB_BUBBLES ; i++ ) {
		sub_bubbles.push( mk_bubble() );
	}


	//	-	-	-	-	-	-	-	-	-	-	-	-
	// Fish stuff

	const NUM_FISH_TYPES = 2;
	let school = [];	// array that holds all the fish
	let vic_num = 0;	// index of frank's current victim in the school array

	const NUM_FISH = 6;
	for( let i = 0 ; i < NUM_FISH ; i++ ) {

		let type = roll( NUM_FISH_TYPES );			// pick a random fish type
		let img = assets[ "fish"+type+"-lt.png" ];	// get the img for that type

		// create the fish
		let fish = new Squid( vec( 0, 0 ), img, 0, 1, 0.4 );
		fish.name = "fish-"+i;
		school.push(fish);	// add it to the school

		// Set collision shape.
		// In this case it will be a rectangle that is the same
		// aspect ratio of the fishes image, but a bit smaller.
		fish.hit_shape = vec( img.size() ).mlt( 0.6 );

		// Sets the visual priority to 2.
		// There are 5 priorities, 1 through 5.
		// Lower numbers appear behind higher numbers.
		fish.draw_priority( 2 );

		// A function that will reset the fish to a new
		// position and swimming direction
		let wrap_fish = function() {
			// default swim from left to right
			fish.position.x = 0;
			fish.velocity = vec( 1.5 + rand(), 0 );
			fish.image = assets["fish"+type+"-rt.png"];
			if( roll( 2 ) ) {	// 50% of the time though ...
				// we'll change it to swim right to left
				fish.position.x = sw - 1;
				fish.velocity = vec( -1.5 + rand(), 0 );
				fish.image = assets["fish"+type+"-lt.png"];
			}
			// now pick a random y position
			fish.position.y = sh * rand();
			vic_num = roll( school.length );	// and pick a new victim for frank
		}

		wrap_fish();

		// Set up a 'tick' handler for the fish.
		fish.listen( "tick", ( delta, tick_num ) => {
			let px = fish.position.x;
			// if fish has hit left or right side of screen, wrap/reset it.
			if( px < 0 || px > sw ) {
				wrap_fish();
			}
		} );

		// listen for 'collide' events.
		fish.listen( "collide", ( collider, self ) => {

			if( collider === frank ) {
				// fish got gobbled up by squid
				if( ! chomp.playing() ) {
					chomp.play();	// play sound effect
				}
				wrap_fish();	// reset fish
				score_frank.score( 1 );	// score one for the squid
				return;
			}

			if( collider === sub ) {
				// fish got captured by submarine
				if( ! chomp.playing() ) {
					chomp.play();
				}
				wrap_fish();
				score_human.score( 1 );	// score one for you!
				return;
			}
		});
	}


	//	-	-	-	-	-	-	-	-	-	-	-	-
	// Frank is a purple squid - isn't he beautiful?

	let img_squid = assets[ "frank.png" ];
	frank = new Squid( vec( sw / 2, sh ), img_squid, 0, 1.0, 0.30 );

	// make an animation for frank
	const frames = [
		assets[ "squid_2.png" ],
		assets[ "squid_4.png" ],
		assets[ "squid_3.png" ],
		assets[ "squid_2.png" ],
		assets[ "squid_1.png" ],
		assets[ "squid_0.png" ],
	];
	frank.anim = new Anim( frames, 15, false, false );	

	let resting = 100;		// countdown timer for resting period between thrusts
	let inking = 0;			// if > 0, then frank is deploying ink

	// Frank's hit shape is a circle that approximates his image size, but somewhat smaller
	frank.hit_shape = img_squid.make_radius() * 0.45;

	// Choose frank's first victim fish
	vic_num = roll( school.length );	// also changed when a fish wraps or is gobbled

	// Set visual priority
	frank.draw_priority( 2 );

	// Listen for the tick event.
	frank.listen( "tick", ( delta, tick_num ) => {

		// type CTRL-` to turn on debug mode so you can see these messages
		if( debug ) {
			dbg_msgs[3] = "frank spd/hdng/resting : "+rndhun(frank.velocity.length())+" "+rndhun(frank.rotation)+" "+rndhun(resting);
			dbg_msgs[4] = "vic_num "+vic_num;
		}

		let f = school[ vic_num ];	// f is the target fish object
		frank.rotate_to( f );		// point frank at the fish

		// if Frank's speed is high, then rest for a bit
		if( frank.velocity.length() > 3 ) {
			resting = 50 + toInt( rand() * 150 );	// set a semi-random resting period
		}

		if( resting > 0 ) {

			// frank is resting
			resting--;
			if( resting == 10 ) {		// if resting is almost over ...
				// start animation playing a little before he
				// actually starts thrusting because that way, it looks more like
				// he's winding up for it.
				frank.anim.play();
			}
			if( resting == 0 ) {			// if resting is over ...
				sploo.play();				// play the thrusting sound
			}

			frank.velocity.mlt( 0.985 );	// apply drag cuz, you know ... water

		} else {

			// no longer resting, so apply thrust
			// Note: This causes an acceleration, but it's negative because otherwise
			// frank goes in the wrong direction, but can't remember why.
			frank.thrust( -0.10 );

		}

		// Count down the inking number
		if( inking > 0 ) {
			inking -= 1;
			// only spew the ink every 20 ticks 
			if( inking % 20 == 0 ) {
				ink();
			}
		}

	} );


	// Both frank and fish MUST listen for "collide" for a hit
	// to be detected by either.
	frank.listen( "collide" );
	frank.name = "frank";


	// Ink blots

	const NUM_BLOTS = 8;		// max # of blots to show
	const BLOT_LIFESPAN = 300;	// in ticks

	// Ink blot constructor
	function Blot( pos ) {
		let blot = new Squid( pos, assets[ "blot.png" ] );
		let alive = 0;
		blot.live = function() {
			alive = BLOT_LIFESPAN;
			blot.die = function() {
				alive = 0;
				blot.ignore( "tick" );
				blot.ignore( "draw_3" );
			}
			blot.listen( "tick", ( delta, tick_num ) => {

				blot.opacity = alive / BLOT_LIFESPAN;
				blot.scale = alive / BLOT_LIFESPAN;

				alive -= 1;
				if( alive <= 0 ) {
					blot.die();
				}
			} );
			blot.draw_priority( 3 );
			blot.position = vec( frank.position );
			blot.rotation = rand() * PI2;
		};
		return blot;
	}

	// Create an array of ink blots
	// NOTE:
	// 		Creating a fixed set of squids up front and then just
	// 		reusing them as needed is a technique that is faster
	// 		then constantly recreating objects and it also reduces
	// 		the risk of overconsuming memory/resources.
	let blots = [];
	for( let i = 0 ; i < NUM_BLOTS ; i++ ) {
		blots[ i ] = new Blot();
		blots[ i ].name = "blot-"+i;
	}

	// when this is called, one of the precreated ink blots will
	// be made visible via it's live() function
	ink = function() {
		// make an ink blot
		let b = blots.shift();	// pull the one off front of array
		b.live();				// resurrect it
		blots.push( b );		// push to end of array
		sploo.play();			// play inking sound
	};


	//	-	-	-	-	-	-	-	-	-	-	-	-
	// A little submarine that you can control

	let img_sub1 = assets[ "sub1.png" ];
	let img_sub2 = assets[ "sub2.png" ];
	let sub = new Squid( vec( sw / 2, sh / 2 ), img_sub1, 0, 1.0, 0.10 );
	sub.name = "sub";
	sub.draw_priority( 2 );
	let bubble_num = 0;
	let sub_facing = 1;		// the direction sub is facing; 1 = right, -1 - left
	sub.listen( "tick", ( delta, tick_num ) => {

		// take note of current key status
		let w = keys[ 'w' ];
		let a = keys[ 'a' ];
		let s = keys[ 's' ];
		let d = keys[ 'd' ];

		// set the facing direction
		sub_facing = a ? -1 : d ? 1 : 0;

		// set the image that corresponds with facing
		sub.image = sub_facing == 1 ? img_sub1 : sub_facing == -1 ? img_sub2 : sub.image;

		// modifying rotation
		sub.rotation = a ? 0.1 : d ? -0.1 : 0;
		sub.rotation *= w ? 3 : s ? -3 : 1;

		// set velocity
		sub.velocity.x = a ? -1 : d ? 1 : sub.velocity.x;
		sub.velocity.y = w ? -1 : s ? 1 : (a || d ) ? -0.1 : sub.velocity.y;

		// if velocity is very small, set it to 0
		if( sub.velocity.length() < 0.1 ) {
			sub.velocity.y = 0.1;
		}

		// maybe apply some drag
		sub.velocity.x *= ( a || d ) ? 1 : 0.99;
		sub.velocity.y *= 0.96;

		// if no keys pressed, sink slowly
		if( ! (a || d || w || s ) ) {
			if( abs( sub.velocity.y ) < 0.1 ) {
				sub.velocity.y = 0.1;
			}
		}

		// if sub hits bottom of screen, stop there.
		if( sub.position.y > sh ) {
			sub.position.y = sh;
		}

		// if going left or right, make bubbles
		if( tick_num % 6 == 0 && ( a || d ) ) {
			let bubble = sub_bubbles[ bubble_num ];
			bubble_num += 1;
			if( bubble_num >= sub_bubbles.length ) {
				bubble_num = 0;		// wrap back to 0
			}
			if( bubble ) {
				// move the bubble to the sub's position
				bubble.position.x = sub.position.x - ( ( img_sub1.w * sub.scale * 0.5 ) * sub_facing );
				bubble.position.y = sub.position.y;
			}
		}

	} );

	sub.hit_shape = sub.image.make_radius() * 0.60;
	sub.listen( "collide" );



	//	-	-	-	-	-	-	-	-	-	-	-	-
	// Tiler
	//
	// TODO Make this into a Squids module
	//
	// A simplistic tiling system just to demonstrate one way of doing it
	// because Squids doesn't support tile maps itself.

	let tile_set = assets[ "tiles.png" ];
	tile_set.smoothing = false;	// turn off smoothing for tiles or it will create artifacts
								// XXX some sort of artifacting is happening in mobile browsers anyway?
	const TILE_SIZE = 32;
	const TILESET_WIDTH = toInt( tile_set.w / TILE_SIZE );
	const TILESET_HEIGHT = toInt( tile_set.h / TILE_SIZE );

	// This converts an ascii char from the simple tile maps below, into
	// an object with the info needed to draw the appropriate image at the 
	// appropriate place for that tile.
	let tile_cvt = ( row, y ) => {
		return row.split("").map( ( ch, x ) => {

			let t = 15;
			switch( ch ) {
			case " ": t = 0; break;
			case "#": t = 1; break;
			case "=": t = 4; break;
			case ":": t = 8; break;
			case "$": t = 12; break;
			case "v": t = 13; break;
			}

			// precompute src x,y and dest xy for each tile in the map so it doesn't
			// have to be done at render time.
			let sx = toInt( t % TILESET_WIDTH ) * TILE_SIZE
			let sy = toInt( t / TILESET_HEIGHT ) * TILE_SIZE
			let dx = x * TILE_SIZE;
			let dy = y * TILE_SIZE;
			let o = { t, sx, sy, dx, dy };

			return o;
		} );
	};

	// we're even going to do a little parallax by having two maps,
	// one layer close and one layer far away.
	let map = [
		"                        =              ",
		"         :              :              ",
		"      ====      v       :             ",
		"      :  :      # v    ::    ###v  =   ",
		" =  $#:v :## = ####    ::  $ ########v ",
		" = #################$= ### $########## ",
	];

	let farmap = [
		"                 $                   $ ",
		"                 $  $===    $        $ ",
		"      ===   $    $  $: :    $  $     $ ",
		"      : :   $    $  $###    $  $   $ $ ",
		"    $ : :v$ $    $  $: :  $ $  $   $ $ ",
		" $ $$ ###$$ $ $  $v $: :$v$$$$ $$  $ $ ",
	];

	let tiles = map.map( tile_cvt );
	let fartiles = farmap.map( tile_cvt );

	const MAP_ROWS = tiles.length;
	const MAP_COLS = tiles[ 0 ].length;
	const TILE_ORIGIN_X = 0;
	const TILE_ORIGIN_Y = sh - ( MAP_ROWS * TILE_SIZE );

	let scr_px = 0;

	// do these multiplications once here, rather than repeatedly inside the loop (faster)
	const tpx = TILE_SIZE * 0.5;
	const tpy = TILE_SIZE * 0.5;
	const draw_tiles = function( tmap, orig_x, orig_y, opa ) {
		for( let y = 0; y < tmap.length; y++ ) {
			let row = tmap[ y ];
			for( let x = 0 ; x < row.length ; x++ ) {
				let { t, sx, sy, dx, dy } = row[ x ];
				let ddx = orig_x + dx;
				let ddy = orig_y + dy;
				draw_image( tile_set, ddx, ddy, opa, 0, tpx, tpy, 1, 1, sx, sy, TILE_SIZE, TILE_SIZE );
			}
		}
	};

	let tiler = new Squid();
	tiler.name = "tiler";
	tiler.draw_priority( 1 );
	let ox = TILE_ORIGIN_X - ( sw * 0.25 );
	let oy = TILE_ORIGIN_Y + ( TILE_SIZE * 0.4 );
	tiler.listen( "draw", () => {
		draw_tiles( fartiles, ox + ( scr_px * 0.4 ), oy, 0.25 );
	} );

	let far_tiler = new Squid();
	far_tiler.name = "far_tiler";
	far_tiler.draw_priority( 2 );
	far_tiler.listen( "draw", () => {
		draw_tiles( tiles, TILE_ORIGIN_X + scr_px, TILE_ORIGIN_Y, 1.0 );
	} );

	tiler.listen( "tick", () => {
		let xpos = ( frank.position.x - ( sw * 0.5 ) ) / sw;
		if( abs( scr_px - xpos ) <= ( sw * 0.3 ) ) {
			scr_px -= xpos ;
		}
	} );

	
	// constructor for a derived, sub-type of Squid that shows text
	function ScoreSquid( name, pos ) {
		let sq = new Squid();
		sq = new Squid();
		sq.draw_priority( 100 );
		sq.name = name;
		sq.text = "";
		sq.font = load_font( "Arial", 30, "#aaa" );
		sq.position = pos;
		sq.points = 0;
		sq.score = function( delta ) {
			sq.points += delta;
			sq.text = sq.name+": "+sq.points;
		};
		sq.score( 0 );
		return sq
	}

	// Use the new constructor to make 2 score-ing squids
	score_frank = new ScoreSquid( "Squid", vec( sw * 0.3, sh * 0.1 ) );
	score_human = new ScoreSquid( "Human", vec( sw * 0.7, sh * 0.1 ) );


	//	-	-	-	-	-	-	-	-	-	-	-	-
	// The overlord
	//
	// Make an all-seeing overlord (more like a low level administrator)
	// that can do some stuff that's not related directly to game play logic

	let god = new Squid();		// the all-seeing overlord 

	god.listen( "tick", ( delta, num ) => {
		if( debug ) {
			dbg_msgs[ 0 ] = "tick "+num
			if( num % 10 == 0 ) {
				dbg_msgs[ 1 ] = "delta "+delta;
				dbg_msgs[ 2 ] = "FPS tick-"+fps_tick+" draw-"+fps_draw;
			}
		}
	} );

	god.draw_priority( 0 );
	god.listen( "draw", () => {
		// draw_0 is emitted first, so clear our background here
		// everything else will be drawn afterward and appear in front of
		// the background.
		fill_rect( 0, 0, sw, sh, "#024");	// draw blue bg
	} );

	// listen for some key events
	god.listen( "keydown", function( k ) {
		if( k == 'm' ) {
			music.volume( 0 );	// turn off the music
			return;
		}
		if( k == 'r' ) {
			start();
			return;
		}
	})

	// listen for pointer event
	god.listen( "pointerdown", function( x, y ) {
		if( collide_pos_squid( vec( x, y ), frank ) ) {
			// clicked on the squid, so squirt some ink
			inking = 100;
		}
	})
}


// Everything is ready.
// Show the loading screen.
load();



